<HTML><HEAD><TITLE>Source</TITLE><STYLE TYPE="text/css">
      BODY { background-color: #F4F4FF }
      .logoindent { margin-left:122px; }
      .smallmargin { margin-left:16px; margin-right:16px; }
      .menus { color: #ffffff; text-decoration: none; }
      .menus:visited { color: #ffffff; text-decoration: none; }
      .menus:hover { text-decoration:underline; }
      .text { font-family: VERDANA,ARIAL; font-size: 13; }
      .invtext { font-family: VERDANA,ARIAL; font-size: 13; color: #ffffff; font: bold; }
      .blackback { background-color: #000000; font-family: VERDANA,ARIAL; font-size: 13; color: #ffffff; }
      .darkerback { background-color: #E4E4F0 }
      .links { color: #000000; text-decoration: none; font: bold; }
      .links:visited { color: #000000; text-decoration: none; font: bold; }
      .links:hover { text-decoration:underline; }

PRE { white-space: nowrap; font-size:13; margin-left:48px }
EM.num { color: #ff0000; font-style:normal }
EM.str { color: #ff0000; font-style:normal }
EM.cmt { color: black; background-color: #E4E4F0; font-style:normal }
</STYLE></HEAD>
<BODY>
    <TABLE CELLPADDING=10>
    <TR HEIGHT=70 VALIGN=CENTER>
<TD ALIGN=CENTER><IMG SRC="images/logo1.gif" WIDTH=72 HEIGHT=72></TD><TD><IMG SRC="images/Fundamentals2.gif" WIDTH=465 HEIGHT=54><BR CLEAR="left"></TD>
</TR>

    <TR><TD COLSPAN=2>
      <TABLE BORDER=1 BORDERCOLOR=#8080FF CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
      <TR BGCOLOR=#8080FF><TD>
        <TABLE><TR>
<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="index.html">Home</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="about.html">About</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="units.html">Units</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="dl.html">Download</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="docs.html">Documents</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="links.html">Links</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="contact.html">Contact</A></TD><TD WIDTH=8></TD><TD BGCOLOR=#FFFFFF WIDTH=0></TD>

<TD WIDTH=8></TD><TD class=invtext><A CLASS=menus HREF="http://sourceforge.net/projects/fundementals/">SourceForge</A></TD><TD WIDTH=8></TD>

        </TR></TABLE>
      </TD></TR>
      </TABLE>
    </TD></TR>
    </TABLE>

<TABLE CELLPADDING=10 WIDTH=100%><TR><TD>
<TABLE BGCOLOR=BLACK WIDTH=100%><TR><TD class=invtext><A CLASS=menus HREF="units.html">Units</A>: <A CLASS=menus HREF="units.html#WinSock">WinSock</A>: Source</TD></TR></TABLE>
<BR>

</TD></TR></TABLE>

<PRE><EM CLASS=cmt>{$INCLUDE ..\cDefines.inc}</EM>
<B>unit</B> cWinSock;

<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{                           WinSock functions 3.05                             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{             This unit is copyright © 2001-2004 by David J Butler             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{                  This unit is part of Delphi Fundamentals.                   }</EM>
<EM CLASS=cmt>{                    Its original file name is cWinSock.pas                    }</EM>
<EM CLASS=cmt>{       The latest version is available from the Fundamentals home page        }</EM>
<EM CLASS=cmt>{                     http://fundementals.sourceforge.net/                     }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{                I invite you to use this unit, free of charge.                }</EM>
<EM CLASS=cmt>{        I invite you to distibute this unit, but it must be for free.         }</EM>
<EM CLASS=cmt>{             I also invite you to contribute to its development,              }</EM>
<EM CLASS=cmt>{             but do not distribute a modified copy of this file.              }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{          A forum is available on SourceForge for general discussion          }</EM>
<EM CLASS=cmt>{             http://sourceforge.net/forum/forum.php?forum_id=2117             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ Description:                                                                 }</EM>
<EM CLASS=cmt>{   Support functions to access WinSock API.                                   }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ Revision history:                                                            }</EM>
<EM CLASS=cmt>{   11/12/2001  0.01  Spawned from cSockets.                                   }</EM>
<EM CLASS=cmt>{   12/12/2001  0.02  Added LocalHost functions.                               }</EM>
<EM CLASS=cmt>{   01/07/2002  3.03  Refactored for Fundamentals 3.                           }</EM>
<EM CLASS=cmt>{   19/08/2003  3.04  Added IPAddressType function.                            }</EM>
<EM CLASS=cmt>{   01/04/2004  3.05  Change to dynamically load WinSock library.              }</EM> 
<EM CLASS=cmt>{                                                                              }</EM>

<B>interface</B>

<B>uses</B>
  <EM CLASS=cmt>{ Delphi }</EM>
  Windows,
  SysUtils,
  Classes,
  WinSock,

  <EM CLASS=cmt>{ Fundamentals }</EM>
  cUtils;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ Dynamically linked WinSock functions                                         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>procedure</B> WSASetLastError(iError: <B>Integer</B>);
<B>function</B>  WSAGetLastError: <B>Integer</B>;
<B>function</B>  WSACancelAsyncRequest(hAsyncTaskHandle: THandle): <B>Integer</B>;
<B>function</B>  WSAAsyncGetHostByName(HWindow: HWND; wMsg: u_int; name, buf: PChar;
          buflen: <B>Integer</B>): THandle;
<B>function</B>  WSAAsyncGetHostByAddr(HWindow: HWND; wMsg: u_int;
          addr: PChar; len, Struct: <B>Integer</B>; buf: PChar; buflen: <B>Integer</B>): THandle;
<B>function</B>  WSAAsyncSelect(s: TSocket; HWindow: HWND; wMsg: u_int; lEvent: Longint): <B>Integer</B>;
<B>function</B>  GetServByName(name, proto: PChar): PServEnt;
<B>function</B>  GetProtoByName(name: PChar): PProtoEnt;
<B>function</B>  GetHostByName(name: PChar): PHostEnt;
<B>function</B>  GetHostByAddr(addr: Pointer; len, Struct: <B>Integer</B>): PHostEnt;
<B>function</B>  GetHostName(name: PChar; len: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  Socket(af, Struct, protocol: <B>Integer</B>): TSocket;
<B>function</B>  Shutdown(s: TSocket; how: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  SetSockOpt(s: TSocket; level, optname: <B>Integer</B>; optval: PChar;
          optlen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  GetSockOpt(s: TSocket; level, optname: <B>Integer</B>; optval: PChar;
          <B>var</B> optlen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  SendTo(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>; <B>var</B> addrto: TSockAddr;
          tolen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  Send(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  Recv(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  RecvFrom(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>; <B>var</B> from: TSockAddr;
          <B>var</B> fromlen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  ntohs(netshort: u_short): u_short;
<B>function</B>  ntohl(netlong: u_long): u_long;
<B>function</B>  Listen(s: TSocket; backlog: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  IoctlSocket(s: TSocket; cmd: DWORD; <B>var</B> arg: u_long): <B>Integer</B>;
<B>function</B>  WSAIoctl(s: TSocket; IoControlCode: DWORD; InBuffer: Pointer;
          InBufferSize: DWORD; OutBuffer: Pointer; OutBufferSize: DWORD;
          <B>var</B> BytesReturned: DWORD; Overlapped: POverlapped;
          CompletionRoutine: FARPROC): <B>Integer</B>;
<B>function</B>  inet_ntoa(inaddr: TInAddr): PChar;
<B>function</B>  inet_addr(cp: PChar): u_long;
<B>function</B>  htons(hostshort: u_short): u_short;
<B>function</B>  htonl(hostlong: u_long): u_long;
<B>function</B>  GetSockName(s: TSocket; <B>var</B> name: TSockAddr; <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  GetPeerName(s: TSocket; <B>var</B> name: TSockAddr; <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  Connect(s: TSocket; <B>var</B> name: TSockAddr; namelen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  CloseSocket(s: TSocket): <B>Integer</B>;
<B>function</B>  Bind(s: TSocket; <B>var</B> addr: TSockAddr; namelen: <B>Integer</B>): <B>Integer</B>;
<B>function</B>  Accept(s: TSocket; addr: PSockAddr; addrlen: PInteger): TSocket;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSockStartup                                                               }</EM>
<EM CLASS=cmt>{   The first call to WinSockStartup initializes the WinSock API. Subsequent   }</EM>
<EM CLASS=cmt>{   calls have no effect. The WinSock API is shut down when the application    }</EM>
<EM CLASS=cmt>{   shuts down.                                                                }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>procedure</B> WinSockStartup;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ Exceptions                                                                   }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>type</B>
  EWinSock = <B>class</B>(Exception);

<B>procedure</B> RaiseSocketError(<B>const</B> Msg: <B>String</B>);
<B>procedure</B> RaiseWinSockError(<B>const</B> Msg: <B>String</B>; <B>const</B> WinSockError: <B>Integer</B>);
<B>procedure</B> RaiseLastWinSockError(<B>const</B> Msg: <B>String</B>);



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSockErrorAsString                                                         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  WinSockErrorAsString(<B>const</B> Error: <B>Integer</B>): <B>String</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ TSocketProtocol                                                              }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>type</B>
  TSocketProtocol = (spTCP, spUDP);

<B>function</B>  SocketProtocolAsString(<B>const</B> Protocol: TSocketProtocol): <B>String</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ IP Addresses                                                                 }</EM>
<EM CLASS=cmt>{   IsIPAddress returns True if Address is a valid IP address. NetAddress      }</EM>
<EM CLASS=cmt>{   contains the address in network byte order.                                }</EM>
<EM CLASS=cmt>{   IsInternetIP returns True if Address appears to be an Internet IP.         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>type</B>
  TInAddr = WinSock.TInAddr;
  TInAddrArray = <B>Array</B> <B>of</B> TInAddr;
  TInAddrArrayArray = <B>Array</B> <B>of</B> TInAddrArray;

<B>type</B>
  TIPAddressType = (ipaPublic, ipaPrivate, ipaNone, ipaReserved,
      ipaLoopback, ipaLinkLocalNetwork, ipaTestNetwork, ipaMulticast,
      ipaBroadcast);

<B>function</B>  IsIPAddress(<B>const</B> Address: <B>String</B>; <B>var</B> NetAddress: TInAddr): <B>Boolean</B>;
<B>function</B>  IPAddressStr(<B>const</B> Address: TInAddr): <B>String</B>;
<B>function</B>  IPAddressType(<B>const</B> Address: TInAddr): TIPAddressType;
<B>function</B>  IsInternetIPAddress(<B>const</B> Address: TInAddr): <B>Boolean</B>;
<B>function</B>  ReversedIP(<B>const</B> Address: TInAddr): TInAddr;
<B>procedure</B> ReverseIP(<B>var</B> Address: TInAddr);



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ ResolvePort                                                                  }</EM>
<EM CLASS=cmt>{   Returns the WinSock error (0 for success).                                 }</EM>
<EM CLASS=cmt>{   NetPort contains the Port value in network byte order.                     }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  ResolvePort(<B>const</B> Port: <B>String</B>; <B>const</B> Protocol: TSocketProtocol;
          <B>var</B> NetPort: Word): <B>Integer</B>;
<B>function</B>  NetPortToPort(<B>const</B> NetPort: Word): Word;
<B>function</B>  NetPortToPortStr(<B>const</B> NetPort: Word): <B>String</B>;
<B>function</B>  PortToNetPort(<B>const</B> Port: Word): Word;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ ResolveHost                                                                  }</EM>
<EM CLASS=cmt>{   Resolves Host (IP or domain name). Blocks. Returns 0 if successful.        }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  ResolveHost(<B>const</B> Host: <B>String</B>; <B>var</B> Address : TInAddr): <B>Integer</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEnt functions                                                            }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  HostEntAddressesCount(<B>const</B> HostEnt: PHostEnt): <B>Integer</B>;
<B>function</B>  HostEntAddresses(<B>const</B> HostEnt: PHostEnt): TInAddrArray;
<B>function</B>  HostEntAddress(<B>const</B> HostEnt: PHostEnt; <B>const</B> Index: <B>Integer</B> = <EM CLASS=num>0</EM>): TInAddr;
<B>function</B>  HostEntAddressStr(<B>const</B> HostEnt: PHostEnt; <B>const</B> Index: <B>Integer</B> = <EM CLASS=num>0</EM>): <B>String</B>;
<B>function</B>  HostEntName(<B>const</B> HostEnt: PHostEnt): <B>String</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ LocalHost                                                                    }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  LocalHostName: <B>String</B>;
<B>function</B>  LocalIPAddresses: TInAddrArray;
<B>function</B>  LocalIPAddressesStr: StringArray;
<B>procedure</B> AddLocalIPAddressesToStrings(<B>const</B> S: TStrings);
<B>function</B>  GuessInternetIP: TInAddr;
<B>function</B>  GuessInternetIPStr: <B>String</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ RemoteHost                                                                   }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  GetRemoteHostName(<B>const</B> Address: TInAddr): <B>String</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ AllocateSocketHandle                                                         }</EM>
<EM CLASS=cmt>{   Returns a handle to a new WinSock socket.                                  }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B>  AllocateSocketHandle(<B>const</B> Protocol: TSocketProtocol): TSocket;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSock structures                                                           }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>procedure</B> PopulateSockAddr(<B>var</B> SockAddr : TSockAddr; <B>const</B> Addr: TInAddr; <B>const</B> Port: Word);



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSock constants                                                            }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>const</B>
  SD_RECEIVE     = <EM CLASS=num>0</EM>;
  SD_SEND        = <EM CLASS=num>1</EM>;
  SD_BOTH        = <EM CLASS=num>2</EM>;

  <EM CLASS=cmt>// WinSock2 Socket Options extentions</EM>
  SO_GROUP_ID              = <EM CLASS=num>$2001</EM>; <EM CLASS=cmt>// ID of a socket group</EM>
  SO_GROUP_PRIORITY        = <EM CLASS=num>$2002</EM>; <EM CLASS=cmt>// the relative priority within a group</EM>
  SO_MAX_MSG_SIZE          = <EM CLASS=num>$2003</EM>; <EM CLASS=cmt>// maximum message size</EM>



<B>implementation</B>

<B>uses</B>
  <EM CLASS=cmt>{ Fundamentals }</EM>
  cStrings;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSock lock                                                                 }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>var</B>
  WinSockLock : TRTLCriticalSection;

<B>procedure</B> InitializeWinSockLock;
<B>begin</B>
  InitializeCriticalSection(WinSockLock);
<B>end</B>;

<B>procedure</B> FinalizeWinSockLock;
<B>begin</B>
  DeleteCriticalSection(WinSockLock);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ Dynamically linked WinSock functions                                         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>type</B>
  TWSAStartupProc            = <B>function</B> (wVersionRequired: Word;
                                         <B>var</B> WSData: TWSAData): <B>Integer</B>; stdcall;
  TWSACleanupProc            = <B>function</B> : <B>Integer</B>; stdcall;
  TWSASetLastErrorProc       = <B>procedure</B> (iError: <B>Integer</B>); stdcall;
  TWSAGetLastErrorProc       = <B>function</B> : <B>Integer</B>; stdcall;
  TWSACancelAsyncRequestProc = <B>function</B> (hAsyncTaskHandle: THandle): <B>Integer</B>; stdcall;
  TWSAAsyncGetHostByNameProc = <B>function</B> (HWindow: HWND; wMsg: u_int; name, buf: PChar;
                                         buflen: <B>Integer</B>): THandle; stdcall;
  TWSAAsyncGetHostByAddrProc = <B>function</B> (HWindow: HWND; wMsg: u_int;
                                         addr: PChar; len, Struct: <B>Integer</B>;
                                         buf: PChar; buflen: <B>Integer</B>): THandle; stdcall;
  TWSAAsyncSelectProc        = <B>function</B> (s: TSocket; HWindow: HWND; wMsg: u_int;
                                         lEvent: Longint): <B>Integer</B>; stdcall;
  TGetServByNameProc         = <B>function</B> (name, proto: PChar): PServEnt; stdcall;
  TGetProtoByNameProc        = <B>function</B> (name: PChar): PProtoEnt; stdcall;
  TGetHostByNameProc         = <B>function</B> (name: PChar): PHostEnt; stdcall;
  TGetHostByAddrProc         = <B>function</B> (addr: Pointer; len, Struct: <B>Integer</B>): PHostEnt; stdcall;
  TGetHostNameProc           = <B>function</B> (name: PChar; len: <B>Integer</B>): <B>Integer</B>; stdcall;
  TSocketProc                = <B>function</B> (af, Struct, protocol: <B>Integer</B>): TSocket; stdcall;
  TShutdownProc              = <B>function</B> (s: TSocket; how: <B>Integer</B>): <B>Integer</B>; stdcall;
  TSetSockOptProc            = <B>function</B> (s: TSocket; level, optname: <B>Integer</B>;
                                         optval: PChar; optlen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TGetSockOptProc            = <B>function</B> (s: TSocket; level, optname: <B>Integer</B>;
                                         optval: PChar; <B>var</B> optlen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TSendToProc                = <B>function</B> (s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>;
                                         <B>var</B> addrto: TSockAddr; tolen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TSendProc                  = <B>function</B> (s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>; stdcall;
  TRecvProc                  = <B>function</B> (s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>; stdcall;
  TRecvFromProc              = <B>function</B> (s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>;
                                         <B>var</B> from: TSockAddr; <B>var</B> fromlen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TntohsProc                 = <B>function</B> (netshort: u_short): u_short; stdcall;
  TntohlProc                 = <B>function</B> (netlong: u_long): u_long; stdcall;
  TListenProc                = <B>function</B> (s: TSocket; backlog: <B>Integer</B>): <B>Integer</B>; stdcall;
  TIoctlSocketProc           = <B>function</B> (s: TSocket; cmd: DWORD;
                                         <B>var</B> arg: u_long): <B>Integer</B>; stdcall;
  TWSAIoctlProc              = <B>function</B> (s                 : TSocket;
                                         IoControlCode     : DWORD;
                                         InBuffer          : Pointer;
                                         InBufferSize      : DWORD;
                                         OutBuffer         : Pointer;
                                         OutBufferSize     : DWORD;
                                         <B>var</B> BytesReturned : DWORD;
                                         Overlapped        : POverlapped;
                                         CompletionRoutine : FARPROC): <B>Integer</B>; stdcall;
  Tinet_ntoaProc             = <B>function</B> (inaddr: TInAddr): PChar; stdcall;
  Tinet_addrProc             = <B>function</B> (cp: PChar): u_long; stdcall;
  ThtonsProc                 = <B>function</B> (hostshort: u_short): u_short; stdcall;
  ThtonlProc                 = <B>function</B> (hostlong: u_long): u_long; stdcall;
  TGetSockNameProc           = <B>function</B> (s: TSocket; <B>var</B> name: TSockAddr;
                                         <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TGetPeerNameProc           = <B>function</B> (s: TSocket; <B>var</B> name: TSockAddr;
                                         <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TConnectProc               = <B>function</B> (s: TSocket; <B>var</B> name: TSockAddr;
                                         namelen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TCloseSocketProc           = <B>function</B> (s: TSocket): <B>Integer</B>; stdcall;
  TBindProc                  = <B>function</B> (s: TSocket; <B>var</B> addr: TSockAddr;
                                         namelen: <B>Integer</B>): <B>Integer</B>; stdcall;
  TAcceptProc                = <B>function</B> (s: TSocket; addr: PSockAddr;
                                         addrlen: PInteger): TSocket; stdcall;

<B>var</B>
  WSAStartupProc            : TWSAStartupProc = nil;
  WSACleanupProc            : TWSACleanupProc = nil;
  WSASetLastErrorProc       : TWSASetLastErrorProc = nil;
  WSAGetLastErrorProc       : TWSAGetLastErrorProc = nil;
  WSACancelAsyncRequestProc : TWSACancelAsyncRequestProc = nil;
  WSAAsyncGetHostByNameProc : TWSAAsyncGetHostByNameProc = nil;
  WSAAsyncGetHostByAddrProc : TWSAAsyncGetHostByAddrProc = nil;
  WSAAsyncSelectProc        : TWSAAsyncSelectProc = nil;
  GetServByNameProc         : TGetServByNameProc = nil;
  GetProtoByNameProc        : TGetProtoByNameProc = nil;
  GetHostByNameProc         : TGetHostByNameProc = nil;
  GetHostByAddrProc         : TGetHostByAddrProc = nil;
  GetHostNameProc           : TGetHostNameProc = nil;
  SocketProc                : TSocketProc = nil;
  ShutdownProc              : TShutdownProc = nil;
  SetSockOptProc            : TSetSockOptProc = nil;
  GetSockOptProc            : TGetSockOptProc = nil;
  SendToProc                : TSendToProc = nil;
  SendProc                  : TSendProc = nil;
  RecvProc                  : TRecvProc = nil;
  RecvFromProc              : TRecvFromProc = nil;
  ntohsProc                 : TntohsProc = nil;
  ntohlProc                 : TntohlProc = nil;
  ListenProc                : TListenProc = nil;
  IoctlSocketProc           : TIoctlSocketProc = nil;
  WSAIoctlProc              : TWSAIoctlProc = nil;
  inet_ntoaProc             : TInet_ntoaProc = nil;
  inet_addrProc             : TInet_addrProc = nil;
  htonsProc                 : ThtonsProc = nil;
  htonlProc                 : ThtonlProc = nil;
  GetSockNameProc           : TGetSockNameProc = nil;
  GetPeerNameProc           : TGetPeerNameProc = nil;
  ConnectProc               : TConnectProc = nil;
  CloseSocketProc           : TCloseSocketProc = nil;
  BindProc                  : TBindProc = nil;
  AcceptProc                : TAcceptProc = nil;

<B>var</B>
  WinSockDLLHandle : HMODULE = <EM CLASS=num>0</EM>;

<B>function</B> GetWinSockProc(<B>const</B> ProcName: <B>String</B>): Pointer;
<B>begin</B>
  EnterCriticalSection(WinSockLock);
  <B>try</B>
    <B>if</B> WinSockDLLHandle = <EM CLASS=num>0</EM> <B>then</B>
      <B>begin</B>
        WinSockDLLHandle := LoadLibrary(<EM CLASS=str>'wsock32.dll'</EM>);
        <B>if</B> WinSockDLLHandle <= HINSTANCE_ERROR <B>then</B>
          <B>begin</B>
            WinSockDLLHandle := <EM CLASS=num>0</EM>;
            RaiseSocketError(<EM CLASS=str>'Unable to load wsock32.dll'</EM>);
          <B>end</B>;
      <B>end</B>;
    Result := GetProcAddress(WinSockDLLHandle, PAnsiChar(ProcName));
    <B>if</B> <B>not</B> Assigned(Result) <B>then</B>
      RaiseSocketError(<EM CLASS=str>'Unable to load wsock32.dll procedure '''</EM> + ProcName + <EM CLASS=str>''''</EM>);
  <B>finally</B>
    LeaveCriticalSection(WinSockLock);
  <B>end</B>;
<B>end</B>;

<B>function</B> WSAStartup(wVersionRequired: Word; <B>var</B> WSData: TWSAData): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAStartupProc) <B>then</B>
    WSAStartupProc := GetWinSockProc(<EM CLASS=str>'WSAStartup'</EM>);
  Result := WSAStartupProc(wVersionRequired, WSData);
<B>end</B>;

<B>function</B> WSACleanup: <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSACleanupProc) <B>then</B>
    WSACleanupProc := GetWinSockProc(<EM CLASS=str>'WSACleanup'</EM>);
  Result := WSACleanupProc;
<B>end</B>;

<B>procedure</B> WSASetLastError(iError: <B>Integer</B>);
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSASetLastErrorProc) <B>then</B>
    WSASetLastErrorProc := GetWinSockProc(<EM CLASS=str>'WSASetLastError'</EM>);
  WSASetLastErrorProc(iError);
<B>end</B>;

<B>function</B> WSAGetLastError: <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAGetLastErrorProc) <B>then</B>
    WSAGetLastErrorProc := GetWinSockProc(<EM CLASS=str>'WSAGetLastError'</EM>);
  Result := WSAGetLastErrorProc;
<B>end</B>;

<B>function</B> WSACancelAsyncRequest(hAsyncTaskHandle: THandle): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSACancelAsyncRequestProc) <B>then</B>
    WSACancelAsyncRequestProc := GetWinSockProc(<EM CLASS=str>'WSACancelAsyncRequest'</EM>);
  Result := WSACancelAsyncRequestProc(hAsyncTaskHandle);
<B>end</B>;

<B>function</B> WSAAsyncGetHostByName(HWindow: HWND; wMsg: u_int; name, buf: PChar;
    buflen: <B>Integer</B>): THandle;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAAsyncGetHostByNameProc) <B>then</B>
    WSAAsyncGetHostByNameProc := GetWinSockProc(<EM CLASS=str>'WSAAsyncGetHostByName'</EM>);
  Result := WSAAsyncGetHostByNameProc(HWindow, wMsg, name, buf, buflen);
<B>end</B>;

<B>function</B> WSAAsyncGetHostByAddr(HWindow: HWND; wMsg: u_int;
    addr: PChar; len, Struct: <B>Integer</B>; buf: PChar; buflen: <B>Integer</B>): THandle;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAAsyncGetHostByAddrProc) <B>then</B>
    WSAAsyncGetHostByAddrProc := GetWinSockProc(<EM CLASS=str>'WSAAsyncGetHostByAddr'</EM>);
  Result := WSAAsyncGetHostByAddrProc(HWindow, wMsg, addr, len, Struct, buf, buflen);
<B>end</B>;

<B>function</B> WSAAsyncSelect(s: TSocket; HWindow: HWND; wMsg: u_int; lEvent: Longint): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAAsyncSelectProc) <B>then</B>
    WSAAsyncSelectProc := GetWinSockProc(<EM CLASS=str>'WSAAsyncSelect'</EM>);
  Result := WSAAsyncSelectProc(s, HWindow, wMsg, lEvent);
<B>end</B>;

<B>function</B> GetServByName(name, proto: PChar): PServEnt;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetServByNameProc) <B>then</B>
    GetServByNameProc := GetWinSockProc(<EM CLASS=str>'getservbyname'</EM>);
  Result := GetServByNameProc(name, proto);
<B>end</B>;

<B>function</B> GetProtoByName(name: PChar): PProtoEnt;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetProtoByNameProc) <B>then</B>
    GetProtoByNameProc := GetWinSockProc(<EM CLASS=str>'getprotobyname'</EM>);
  Result := GetProtoByNameProc(name);
<B>end</B>;

<B>function</B> GetHostByName(name: PChar): PHostEnt;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetHostByNameProc) <B>then</B>
    GetHostByNameProc := GetWinSockProc(<EM CLASS=str>'gethostbyname'</EM>);
  Result := GetHostByNameProc(name);
<B>end</B>;

<B>function</B> GetHostByAddr(addr: Pointer; len, Struct: <B>Integer</B>): PHostEnt;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetHostByAddrProc) <B>then</B>
    GetHostByAddrProc := GetWinSockProc(<EM CLASS=str>'gethostbyaddr'</EM>);
  Result := GetHostByAddrProc(addr, len, Struct);
<B>end</B>;

<B>function</B> GetHostName(name: PChar; len: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetHostNameProc) <B>then</B>
    GetHostNameProc := GetWinSockProc(<EM CLASS=str>'gethostname'</EM>);
  Result := GetHostNameProc(name, len);
<B>end</B>;

<B>function</B> Socket(af, Struct, protocol: <B>Integer</B>): TSocket;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(SocketProc) <B>then</B>
    SocketProc := GetWinSockProc(<EM CLASS=str>'socket'</EM>);
  Result := SocketProc(af, Struct, protocol);
<B>end</B>;

<B>function</B> Shutdown(s: TSocket; how: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(ShutdownProc) <B>then</B>
    ShutdownProc := GetWinSockProc(<EM CLASS=str>'shutdown'</EM>);
  Result := ShutdownProc(s, how);
<B>end</B>;

<B>function</B> SetSockOpt(s: TSocket; level, optname: <B>Integer</B>; optval: PChar;
    optlen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(SetSockOptProc) <B>then</B>
    SetSockOptProc := GetWinSockProc(<EM CLASS=str>'setsockopt'</EM>);
  Result := SetSockOptProc(s, level, optname, optval, optlen);
<B>end</B>;

<B>function</B> GetSockOpt(s: TSocket; level, optname: <B>Integer</B>; optval: PChar;
    <B>var</B> optlen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetSockOptProc) <B>then</B>
    GetSockOptProc := GetWinSockProc(<EM CLASS=str>'getsockopt'</EM>);
  Result := GetSockOptProc(s, level, optname, optval, optlen);
<B>end</B>;

<B>function</B> SendTo(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>; <B>var</B> addrto: TSockAddr;
    tolen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(SendToProc) <B>then</B>
    SendToProc := GetWinSockProc(<EM CLASS=str>'sendto'</EM>);
  Result := SendToProc(s, Buf, len, flags, addrto, tolen);
<B>end</B>;

<B>function</B> Send(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(SendProc) <B>then</B>
    SendProc := GetWinSockProc(<EM CLASS=str>'send'</EM>);
  Result := SendProc(s, Buf, len, flags);
<B>end</B>;

<B>function</B> Recv(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(RecvProc) <B>then</B>
    RecvProc := GetWinSockProc(<EM CLASS=str>'recv'</EM>);
  Result := RecvProc(s, Buf, len, flags);
<B>end</B>;

<B>function</B> RecvFrom(s: TSocket; <B>var</B> Buf; len, flags: <B>Integer</B>; <B>var</B> from: TSockAddr;
    <B>var</B> fromlen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(RecvFromProc) <B>then</B>
    RecvFromProc := GetWinSockProc(<EM CLASS=str>'recvfrom'</EM>);
  Result := RecvFromProc(s, Buf, len, flags, from, fromlen);
<B>end</B>;

<B>function</B> ntohs(netshort: u_short): u_short;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(ntohsProc) <B>then</B>
    ntohsProc := GetWinSockProc(<EM CLASS=str>'ntohs'</EM>);
  Result := ntohsProc(netshort);
<B>end</B>;

<B>function</B> ntohl(netlong: u_long): u_long;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(ntohlProc) <B>then</B>
    ntohlProc := GetWinSockProc(<EM CLASS=str>'ntohl'</EM>);
  Result := ntohlProc(netlong);
<B>end</B>;

<B>function</B> Listen(s: TSocket; backlog: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(ListenProc) <B>then</B>
    ListenProc := GetWinSockProc(<EM CLASS=str>'listen'</EM>);
  Result := ListenProc(s, backlog);
<B>end</B>;

<B>function</B> IoctlSocket(s: TSocket; cmd: DWORD; <B>var</B> arg: u_long): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(IoctlSocketProc) <B>then</B>
    IoctlSocketProc := GetWinSockProc(<EM CLASS=str>'ioctlsocket'</EM>);
  Result := IoctlSocketProc(s, cmd, arg);
<B>end</B>;

<B>function</B> WSAIoctl(s: TSocket; IoControlCode: DWORD; InBuffer: Pointer;
    InBufferSize: DWORD; OutBuffer: Pointer; OutBufferSize: DWORD;
    <B>var</B> BytesReturned: DWORD; Overlapped: POverlapped;
    CompletionRoutine: FARPROC): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(WSAIoctlProc) <B>then</B>
    WSAIoctlProc := GetWinSockProc(<EM CLASS=str>'WSAIoctl'</EM>);
  Result := WSAIoctlProc(s, IoControlCode, InBuffer, InBufferSize,
      OutBuffer, OutBufferSize, BytesReturned, Overlapped, CompletionRoutine);
<B>end</B>;

<B>function</B> inet_ntoa(inaddr: TInAddr): PChar;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(Inet_ntoaProc) <B>then</B>
    Inet_ntoaProc := GetWinSockProc(<EM CLASS=str>'inet_ntoa'</EM>);
  Result := Inet_ntoaProc(inaddr);
<B>end</B>;

<B>function</B> inet_addr(cp: PChar): u_long;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(Inet_addrProc) <B>then</B>
    Inet_addrProc := GetWinSockProc(<EM CLASS=str>'inet_addr'</EM>);
  Result := Inet_addrProc(cp);
<B>end</B>;

<B>function</B> htons(hostshort: u_short): u_short;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(htonsProc) <B>then</B>
    htonsProc := GetWinSockProc(<EM CLASS=str>'htons'</EM>);
  Result := htonsProc(hostshort);
<B>end</B>;

<B>function</B> htonl(hostlong: u_long): u_long;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(htonlProc) <B>then</B>
    htonlProc := GetWinSockProc(<EM CLASS=str>'htonl'</EM>);
  Result := htonlProc(hostlong);
<B>end</B>;

<B>function</B> GetSockName(s: TSocket; <B>var</B> name: TSockAddr; <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetSockNameProc) <B>then</B>
    GetSockNameProc := GetWinSockProc(<EM CLASS=str>'getsockname'</EM>);
  Result := GetSockNameProc(s, name, namelen);
<B>end</B>;

<B>function</B> GetPeerName(s: TSocket; <B>var</B> name: TSockAddr; <B>var</B> namelen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(GetPeerNameProc) <B>then</B>
    GetPeerNameProc := GetWinSockProc(<EM CLASS=str>'getpeername'</EM>);
  Result := GetPeerNameProc(s, name, namelen);
<B>end</B>;

<B>function</B> Connect(s: TSocket; <B>var</B> name: TSockAddr; namelen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(ConnectProc) <B>then</B>
    ConnectProc := GetWinSockProc(<EM CLASS=str>'connect'</EM>);
  Result := ConnectProc(s, name, namelen);
<B>end</B>;

<B>function</B> CloseSocket(s: TSocket): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(CloseSocketProc) <B>then</B>
    CloseSocketProc := GetWinSockProc(<EM CLASS=str>'closesocket'</EM>);
  Result := CloseSocketProc(s);
<B>end</B>;

<B>function</B> Bind(s: TSocket; <B>var</B> addr: TSockAddr; namelen: <B>Integer</B>): <B>Integer</B>;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(BindProc) <B>then</B>
    BindProc := GetWinSockProc(<EM CLASS=str>'bind'</EM>);
  Result := BindProc(s, addr, namelen);
<B>end</B>;

<B>function</B> Accept(s: TSocket; addr: PSockAddr; addrlen: PInteger): TSocket;
<B>begin</B>
  <B>if</B> <B>not</B> Assigned(AcceptProc) <B>then</B>
    AcceptProc := GetWinSockProc(<EM CLASS=str>'accept'</EM>);
  Result := AcceptProc(s, addr, addrlen);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSockStartup / WinSockCleanup                                              }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>var</B>
  WinSockStarted : <B>Boolean</B> = <B>False</B>;
  WinSockData    : WSAData;

<B>procedure</B> WinSockStartup;
<B>var</B> Err : <B>Integer</B>;
<B>begin</B>
  EnterCriticalSection(WinSockLock);
  <B>try</B>
    <B>if</B> WinSockStarted <B>then</B>
      exit;
    Err := WSAStartup(<EM CLASS=num>$101</EM>, WinSockData);
    <B>if</B> Err <> <EM CLASS=num>0</EM> <B>then</B>
      RaiseWinSockError(<EM CLASS=str>'Winsock startup failed'</EM>, Err);
    WinSockStarted := <B>True</B>;
  <B>finally</B>
    LeaveCriticalSection(WinSockLock);
  <B>end</B>;
<B>end</B>;

<B>procedure</B> WinSockCleanup;
<B>begin</B>
  EnterCriticalSection(WinSockLock);
  <B>try</B>
    <B>if</B> WinSockStarted <B>then</B>
      <B>begin</B>
        WSACleanup;
        WinSockStarted := <B>False</B>;
      <B>end</B>;
    <B>if</B> WinSockDLLHandle <> <EM CLASS=num>0</EM> <B>then</B>
      <B>begin</B>
        FreeLibrary(WinSockDLLHandle);
        WinSockDLLHandle := <EM CLASS=num>0</EM>;
      <B>end</B>;
  <B>finally</B>
    LeaveCriticalSection(WinSockLock);
  <B>end</B>;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ RaiseSocketError                                                             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>procedure</B> RaiseSocketError(<B>const</B> Msg: <B>String</B>);
<B>begin</B>
  <B>raise</B> EWinSock.Create(Msg);
<B>end</B>;

<B>procedure</B> RaiseWinSockError(<B>const</B> Msg: <B>String</B>; <B>const</B> WinSockError: <B>Integer</B>);
<B>begin</B>
  RaiseSocketError(Msg + <EM CLASS=str>': '</EM> + WinSockErrorAsString(WinSockError));
<B>end</B>;

<B>procedure</B> RaiseLastWinSockError(<B>const</B> Msg: <B>String</B>);
<B>begin</B>
  RaiseWinSockError(Msg, WSAGetLastError);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSockErrorAsString                                                         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> WinSockErrorAsString(<B>const</B> Error: <B>Integer</B>): <B>String</B>;
<B>begin</B>
  <B>Case</B> Error <B>of</B>
    <EM CLASS=num>0</EM>                  : Result := <EM CLASS=str>''</EM>;
    WSASYSNOTREADY     : Result := <EM CLASS=str>'WinSock not ready'</EM>;
    WSAVERNOTSUPPORTED : Result := <EM CLASS=str>'WinSock version not supported'</EM>;
    WSAEINPROGRESS     : Result := <EM CLASS=str>'Blocking WinSock operation in progress'</EM>;
    WSAEPROCLIM        : Result := <EM CLASS=str>'WinSock task limit reached'</EM>;
    WSAEFAULT          : Result := <EM CLASS=str>'Generic WinSock fault'</EM>;
    WSANOTINITIALISED  : Result := <EM CLASS=str>'WinSock not initialized'</EM>;
    WSAENETDOWN        : Result := <EM CLASS=str>'The network subsystem has failed'</EM>;
    WSAENETUNREACH     : Result := <EM CLASS=str>'The network is unreachable'</EM>;
    WSAENETRESET       : Result := <EM CLASS=str>'Network reset'</EM>;
    WSAEHOSTDOWN       : Result := <EM CLASS=str>'Host is unavailable'</EM>;
    WSAEHOSTUNREACH    : Result := <EM CLASS=str>'Host is unreachable'</EM>;
    WSAHOST_NOT_FOUND  : Result := <EM CLASS=str>'Host not found'</EM>;
    WSATRY_AGAIN       : Result := <EM CLASS=str>'Host not found'</EM>;
    WSANO_DATA         : Result := <EM CLASS=str>'Host address not found'</EM>;
    WSAECONNRESET      : Result := <EM CLASS=str>'Connection reset by peer'</EM>;
    WSANO_RECOVERY     : Result := <EM CLASS=str>'Nonrecoverable WinSock error occurred'</EM>;
    WSAEMFILE          : Result := <EM CLASS=str>'WinSock file error'</EM>;
    WSAENOBUFS        : Result := <EM CLASS=str>'No buffer space available for socket'</EM>;
    WSAESOCKTNOSUPPORT : Result := <EM CLASS=str>'The socket type is not supported'</EM>;
    WSAENOTSOCK        : Result := <EM CLASS=str>'Socket operation on non-socket or not connected'</EM>;
    WSAENOTCONN        : Result := <EM CLASS=str>'Socket is not connected'</EM>;
    WSAESHUTDOWN       : Result := <EM CLASS=str>'Socket is shutting down'</EM>;
    WSAETIMEDOUT       : Result := <EM CLASS=str>'Socket operation timed out'</EM>;
    WSAECONNREFUSED    : Result := <EM CLASS=str>'Connection refused'</EM>;
    WSAEADDRINUSE      : Result := <EM CLASS=str>'Address in use'</EM>;
    WSAEADDRNOTAVAIL   : Result := <EM CLASS=str>'Address not available'</EM>;
    WSAEBADF           : Result := <EM CLASS=str>'Socket error: Invalid format'</EM>;
    WSAEINVAL          : Result := <EM CLASS=str>'Socket error: Invalid operation'</EM>;
    WSAEACCES          : Result := <EM CLASS=str>'Socket permission denied'</EM>;
    WSAEMSGSIZE        : Result := <EM CLASS=str>'Socket error: Invalid message size'</EM>;
    WSAENOPROTOOPT     : Result := <EM CLASS=str>'Protocol not available'</EM>;
    WSAEPROTONOSUPPORT : Result := <EM CLASS=str>'Protocol not supported'</EM>;
    WSAEPFNOSUPPORT    : Result := <EM CLASS=str>'Protocol family not supported'</EM>;
    WSAEAFNOSUPPORT    : Result := <EM CLASS=str>'Address family not supported by protocol family'</EM>;
    WSAEOPNOTSUPP      : Result := <EM CLASS=str>'Socket error: Operation not supported'</EM>;
    WSAENAMETOOLONG    : Result := <EM CLASS=str>'Socket error: Name too long'</EM>;
    WSAEINTR           : Result := <EM CLASS=str>'Socket error: System level interruption'</EM>;
    WSAECONNABORTED    : Result := <EM CLASS=str>'Connection aborted'</EM>;
    WSAEDISCON         : Result := <EM CLASS=str>'Socket has been disconnected'</EM>;
  <B>else</B>
    Result := <EM CLASS=str>'WinSock error #'</EM> + IntToStr(Error);
  <B>end</B>;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ SocketProtocolAsString                                                       }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>const</B>
  ProtocolStr: <B>Array</B>[TSocketProtocol] <B>of</B> <B>String</B> = (<EM CLASS=str>'tcp'</EM>, <EM CLASS=str>'udp'</EM>);

<B>function</B> SocketProtocolAsString(<B>const</B> Protocol: TSocketProtocol): <B>String</B>;
<B>begin</B>
  Result := ProtocolStr[Protocol];
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ IsIPAddress                                                                  }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> IsIPAddress(<B>const</B> Address: <B>String</B>; <B>var</B> NetAddress: TInAddr): <B>Boolean</B>;
<B>var</B> P, Q : PChar;
    I    : <B>Integer</B>;
<B>begin</B>
  <EM CLASS=cmt>// Not long enough</EM>
  <B>if</B> Length(Address) < <EM CLASS=num>7</EM> <B>then</B>
    <B>begin</B>
      NetAddress.S_addr := u_long(INADDR_NONE);
      Result := <B>False</B>;
      exit;
    <B>end</B>;

  <EM CLASS=cmt>// Quick validity checking</EM>
  P := PChar(Address);
  <B>While</B> P^ = <EM CLASS=str>' '</EM> <B>do</B>
    Inc(P);
  Q := P;
  I := <EM CLASS=num>0</EM>;
  <B>While</B> Q^ <> <EM CLASS=str>#</EM><EM CLASS=num>0</EM> <B>do</B>
    <B>if</B> <B>not</B> (Q^ <B>in</B> [<EM CLASS=str>'0'</EM>..<EM CLASS=str>'9'</EM>, <EM CLASS=str>'.'</EM>, <EM CLASS=str>' '</EM>]) <B>then</B>
      <B>begin</B>
        NetAddress.S_addr := u_long(INADDR_NONE);
        Result := <B>False</B>;
        exit;
      <B>end</B> <B>else</B>
      <B>begin</B>
        <B>if</B> Q^ = <EM CLASS=str>'.'</EM> <B>then</B>
          Inc(I);
        Inc(Q);
      <B>end</B>;
  <B>if</B> I <> <EM CLASS=num>3</EM> <B>then</B> <EM CLASS=cmt>// 3 dots required</EM>
    <B>begin</B>
      NetAddress.S_addr := u_long(INADDR_NONE);
      Result := <B>False</B>;
      exit;
    <B>end</B>;

  <EM CLASS=cmt>// Use WinSock to resolve IP</EM>
  <B>if</B> <B>not</B> WinSockStarted <B>then</B>
    WinSockStartup;
  NetAddress.S_addr := Inet_Addr(P);
  <B>if</B> NetAddress.S_addr <> u_long(INADDR_NONE) <B>then</B>
    Result := <B>True</B> <B>else</B>
    <B>if</B> Address = <EM CLASS=str>'255.255.255.255'</EM> <B>then</B> <EM CLASS=cmt>// Check for broadcast IP (INADDR_NONE = INADDR_BROADCAST)</EM>
      <B>begin</B>
        NetAddress.S_addr := u_long(INADDR_BROADCAST);
        Result := <B>True</B>;
      <B>end</B> <B>else</B>
      Result := <B>False</B>;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ IPAddressStr                                                                 }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> IPAddressStr(<B>const</B> Address: TInAddr): <B>String</B>;
<B>begin</B>
  Result := PChar(inet_ntoa(Address));
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ ResolvePort                                                                  }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> ResolvePort(<B>const</B> Port: <B>String</B>; <B>const</B> Protocol: TSocketProtocol;
    <B>var</B> NetPort: Word): <B>Integer</B>;
<B>var</B> PEnt : PServEnt;
    Prot : <B>String</B>;
<B>begin</B>
  <B>if</B> Port = <EM CLASS=str>''</EM> <B>then</B>
    <B>begin</B>
      NetPort := <EM CLASS=num>0</EM>;
      Result := <EM CLASS=num>0</EM>;
      exit;
    <B>end</B>;
  <B>if</B> StrIsNumeric(Port) <B>then</B>
    <B>begin</B>
      NetPort := htons(StrToInt(Port));
      Result := <EM CLASS=num>0</EM>;
      exit;
    <B>end</B>;
  <B>if</B> <B>not</B> WinSockStarted <B>then</B>
    WinSockStartup;
  Prot := SocketProtocolAsString(Protocol);
  PEnt := GetServByName(PChar(Port), PChar(Prot));
  <B>if</B> <B>not</B> Assigned(PEnt) <B>then</B>
    <B>begin</B>
      NetPort := <EM CLASS=num>0</EM>;
      Result := WSAGetLastError;
    <B>end</B> <B>else</B>
    <B>begin</B>
      NetPort := PEnt^.s_port;
      Result := <EM CLASS=num>0</EM>;
    <B>end</B>;
<B>end</B>;

<B>function</B> NetPortToPort(<B>const</B> NetPort: Word): Word;
<B>begin</B>
  Result := ntohs(NetPort);
<B>end</B>;

<B>function</B> NetPortToPortStr(<B>const</B> NetPort: Word): <B>String</B>;
<B>begin</B>
  Result := IntToStr(NetPortToPort(NetPort));
<B>end</B>;

<B>function</B> PortToNetPort(<B>const</B> Port: Word): Word;
<B>begin</B>
  Result := htons(Port);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ ResolveHost                                                                  }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> ResolveHost(<B>const</B> Host: <B>String</B>; <B>var</B> Address : TInAddr): <B>Integer</B>;
<B>var</B> HostEnt : PHostEnt;
<B>begin</B>
  <B>if</B> IsIPAddress(Host, Address) <B>then</B>
    <B>begin</B>
      Result := <EM CLASS=num>0</EM>;
      exit;
    <B>end</B>;
  HostEnt := GetHostByName(PChar(Host));
  Result := WSAGetLastError;
  <B>if</B> Assigned(HostEnt) <B>then</B>
    Address := HostEntAddress(HostEnt, <EM CLASS=num>0</EM>) <B>else</B>
    Address.S_addr := u_long(INADDR_NONE);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEntAddressCount                                                          }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> HostEntAddressesCount(<B>const</B> HostEnt: PHostEnt): <B>Integer</B>;
<B>var</B> P : ^PInAddr;
    Q : PInAddr;
<B>begin</B>
  Result := <EM CLASS=num>0</EM>;
  <B>if</B> <B>not</B> Assigned(HostEnt) <B>then</B>
    exit;

  Assert(HostEnt^.h_addrtype = AF_INET, <EM CLASS=str>'IP addresses required'</EM>);
  Assert(HostEnt^.h_length = Sizeof(TInAddr), <EM CLASS=str>'IP addresses required'</EM>);

  P := Pointer(HostEnt^.h_addr_list);
  <B>if</B> <B>not</B> Assigned(P) <B>then</B>
    exit;
  Q := P^;
  <B>While</B> Assigned(Q) <B>do</B>
    <B>begin</B>
      Inc(P);
      Inc(Result);
      Q := P^
    <B>end</B>;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEntAddresses                                                             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> HostEntAddresses(<B>const</B> HostEnt: PHostEnt): TInAddrArray;
<B>var</B> P : ^PInAddr;
    I, L : <B>Integer</B>;
<B>begin</B>
  L := HostEntAddressesCount(HostEnt);
  SetLength(Result, L);
  <B>if</B> L = <EM CLASS=num>0</EM> <B>then</B>
    exit;
  P := Pointer(HostEnt^.h_addr_list);
  <B>For</B> I := <EM CLASS=num>0</EM> <B>to</B> L - <EM CLASS=num>1</EM> <B>do</B>
    <B>begin</B>
      Result[I] := P^^;
      Inc(P);
    <B>end</B>;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEntAddress                                                               }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> HostEntAddress(<B>const</B> HostEnt: PHostEnt; <B>const</B> Index: <B>Integer</B>): TInAddr;
<B>var</B> P : ^PInAddr;
    Q : PInAddr;
    I : <B>Integer</B>;
<B>begin</B>
  LongInt(Result.S_addr) := LongInt(INADDR_NONE);
  <B>if</B> <B>not</B> Assigned(HostEnt) <B>then</B>
    exit;

  Assert(HostEnt^.h_addrtype = AF_INET, <EM CLASS=str>'IP addresses required'</EM>);
  Assert(HostEnt^.h_length = Sizeof(TInAddr), <EM CLASS=str>'IP addresses required'</EM>);

  P := Pointer(HostEnt^.h_addr_list);
  <B>if</B> <B>not</B> Assigned(P) <B>then</B>
    exit;
  Q := P^;
  I := <EM CLASS=num>0</EM>;
  <B>While</B> Assigned(Q) <B>and</B> (I < Index) <B>do</B>
    <B>begin</B>
      Inc(P);
      Inc(I);
      Q := P^
    <B>end</B>;
  <B>if</B> Assigned(Q) <B>then</B>
    Result := Q^;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEntAddressStr                                                            }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> HostEntAddressStr(<B>const</B> HostEnt: PHostEnt; <B>const</B> Index: <B>Integer</B>): <B>String</B>;
<B>begin</B>
  Result := IPAddressStr(HostEntAddress(HostEnt, Index));
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ HostEntName                                                                  }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> HostEntName(<B>const</B> HostEnt: PHostEnt): <B>String</B>;
<B>begin</B>
  Result := HostEnt.h_name;
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ LocalHostName                                                                }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> LocalHostName: <B>String</B>;
<B>var</B> Buf : <B>Array</B>[<EM CLASS=num>0.</EM>.<EM CLASS=num>255</EM>] <B>of</B> Char;
<B>begin</B>
  <B>if</B> <B>not</B> WinSockStarted <B>then</B>
    WinSockStartup;
  <B>if</B> gethostname(@Buf, Sizeof(Buf)) <> <EM CLASS=num>0</EM> <B>then</B>
    RaiseLastWinSockError(<EM CLASS=str>'LocalHostName not available'</EM>);
  Result := PChar(@Buf);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ LocalIPAddress                                                               }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> LocalIPAddresses: TInAddrArray;
<B>begin</B>
  <B>if</B> <B>not</B> WinSockStarted <B>then</B>
    WinSockStartup;
  Result := HostEntAddresses(gethostbyname(PChar(LocalHostName)));
<B>end</B>;

<B>function</B> LocalIPAddressesStr: StringArray;
<B>var</B> V : TInAddrArray;
    I, L : <B>Integer</B>;
<B>begin</B>
  V := LocalIPAddresses;
  L := Length(V);
  SetLength(Result, L);
  <B>For</B> I := <EM CLASS=num>0</EM> <B>to</B> L - <EM CLASS=num>1</EM> <B>do</B>
    Result[I] := IPAddressStr(V[I]);
<B>end</B>;

<B>procedure</B> AddLocalIPAddressesToStrings(<B>const</B> S: TStrings);
<B>var</B> V : TInAddrArray;
    I, L : <B>Integer</B>;
<B>begin</B>
  V := LocalIPAddresses;
  L := Length(V);
  <B>For</B> I := <EM CLASS=num>0</EM> <B>to</B> L - <EM CLASS=num>1</EM> <B>do</B>
    S.Add(IPAddressStr(V[I]));
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ IP Address Types                                                             }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> IPAddressType(<B>const</B> Address: TInAddr): TIPAddressType;
<B>begin</B>
  Result := ipaPublic;
  <B>Case</B> Byte(Address.S_un_b.s_b1) <B>of</B>
    <EM CLASS=num>0</EM>        : <B>if</B> LongWord(Address.S_addr) = <EM CLASS=num>0</EM> <B>then</B>
                 Result := ipaNone;
    <EM CLASS=num>10</EM>       : Result := ipaPrivate;
    <EM CLASS=num>127</EM>      : Result := ipaLoopback;
    <EM CLASS=num>169</EM>      : <B>if</B> Byte(Address.S_un_b.s_b2) = <EM CLASS=num>254</EM> <B>then</B>
                 Result := ipaLinkLocalNetwork;
    <EM CLASS=num>172</EM>      : <B>if</B> Byte(Address.S_un_b.s_b2) <B>and</B> <EM CLASS=num>$F0</EM> = <EM CLASS=num>$10</EM> <B>then</B>
                 Result := ipaPrivate;
    <EM CLASS=num>192</EM>      : <B>Case</B> Byte(Address.S_un_b.s_b2) <B>of</B>
                 <EM CLASS=num>0</EM>   : <B>if</B> Byte(Address.S_un_b.s_b3) = <EM CLASS=num>2</EM> <B>then</B>
                         Result := ipaTestNetwork;
                 <EM CLASS=num>168</EM> : Result := ipaPrivate;
               <B>end</B>;
    <EM CLASS=num>224.</EM>.<EM CLASS=num>239</EM> : Result := ipaMulticast;
    <EM CLASS=num>255</EM>      : <B>if</B> LongWord(Address.S_addr) = <EM CLASS=num>$FFFFFFFF</EM> <B>then</B>
                 Result := ipaBroadcast;
  <B>end</B>;
  <B>if</B> Result = ipaPublic <B>then</B>
    <B>if</B> Byte(Address.S_un_b.s_b1) <B>in</B> [<EM CLASS=num>0.</EM>.<EM CLASS=num>2</EM>, <EM CLASS=num>5</EM>, <EM CLASS=num>7</EM>, <EM CLASS=num>23</EM>, <EM CLASS=num>27</EM>, <EM CLASS=num>31</EM>, <EM CLASS=num>36.</EM>.<EM CLASS=num>37</EM>,
        <EM CLASS=num>39</EM>, <EM CLASS=num>41.</EM>.<EM CLASS=num>42</EM>, <EM CLASS=num>58.</EM>.<EM CLASS=num>59</EM>, <EM CLASS=num>70.</EM>.<EM CLASS=num>79</EM>, <EM CLASS=num>83.</EM>.<EM CLASS=num>127</EM>, <EM CLASS=num>197</EM>, <EM CLASS=num>223</EM>, <EM CLASS=num>240.</EM>.<EM CLASS=num>255</EM>] <B>then</B>
      Result := ipaReserved;
<B>end</B>;

<B>function</B> IsInternetIPAddress(<B>const</B> Address: TInAddr): <B>Boolean</B>;
<B>begin</B>
  Result := IPAddressType(Address) = ipaPublic;
<B>end</B>;

<B>function</B> ReversedIP(<B>const</B> Address: TInAddr): TInAddr;
<B>begin</B>
  Result.S_addr := Address.S_addr;
  Swap(Byte(Result.S_un_b.s_b1), Byte(Result.S_un_b.s_b4));
  Swap(Byte(Result.S_un_b.s_b2), Byte(Result.S_un_b.s_b3));
<B>end</B>;

<B>procedure</B> ReverseIP(<B>var</B> Address: TInAddr);
<B>begin</B>
  Swap(Byte(Address.S_un_b.s_b1), Byte(Address.S_un_b.s_b4));
  Swap(Byte(Address.S_un_b.s_b2), Byte(Address.S_un_b.s_b3));
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ GuessInternetIP                                                              }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> GuessInternetIP: TInAddr;
<B>var</B> A : TInAddrArray;
    I : <B>Integer</B>;
<B>begin</B>
  A := LocalIPAddresses;
  <B>For</B> I := <EM CLASS=num>0</EM> <B>to</B> Length(A) - <EM CLASS=num>1</EM> <B>do</B>
    <B>if</B> IsInternetIPAddress(A[I]) <B>then</B>
      <B>begin</B>
        Result := A[I];
        exit;
      <B>end</B>;
  LongInt(Result.S_addr) := LongInt(INADDR_NONE);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ GuessInternetIPStr                                                           }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> GuessInternetIPStr: <B>String</B>;
<B>var</B> A : TInAddr;
<B>begin</B>
  A := GuessInternetIP;
  <B>if</B> LongInt(A) = LongInt(INADDR_NONE) <B>then</B>
    Result := <EM CLASS=str>''</EM> <B>else</B>
    Result := IPAddressStr(A);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ RemoteHost                                                                   }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> GetRemoteHostName(<B>const</B> Address: TInAddr): <B>String</B>;
<B>var</B> E : PHostEnt;
<B>begin</B>
  E := gethostbyaddr(@Address, Sizeof(TInAddr), AF_INET);
  <B>if</B> <B>not</B> Assigned(E) <B>then</B>
    <B>begin</B>
      Result := <EM CLASS=str>''</EM>;
      exit;
    <B>end</B>;
  Result := StrPas(E^.h_name);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ AllocateSocketHandle                                                         }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>function</B> AllocateSocketHandle(<B>const</B> Protocol: TSocketProtocol): TSocket;
<B>begin</B>
  <B>if</B> <B>not</B> WinSockStarted <B>then</B>
    WinSockStartup;
  <B>Case</B> Protocol <B>of</B>
    spTCP : Result := Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    spUDP : Result := Socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    <B>else</B> Result := INVALID_SOCKET;
  <B>end</B>;
  <B>if</B> Result = INVALID_SOCKET <B>then</B>
    RaiseLastWinSockError(<EM CLASS=str>'Socket allocation failed'</EM>);
<B>end</B>;



<EM CLASS=cmt>{                                                                              }</EM>
<EM CLASS=cmt>{ WinSock structures                                                           }</EM>
<EM CLASS=cmt>{                                                                              }</EM>
<B>procedure</B> PopulateSockAddr(<B>var</B> SockAddr: TSockAddr; <B>const</B> Addr: TInAddr; <B>const</B> Port: Word);
<B>begin</B>
  FillChar(SockAddr, Sizeof(TSockAddr), <EM CLASS=str>#</EM><EM CLASS=num>0</EM>);
  With SockAddr <B>do</B>
    <B>begin</B>
      sin_family := AF_INET;
      sin_port := htons(Port);
      sin_addr := Addr;
    <B>end</B>;
<B>end</B>;



<B>initialization</B>
  InitializeWinSockLock;
<B>finalization</B>
  WinSockCleanup;
  FinalizeWinSockLock;
<B>end</B>.


</PRE></BODY>
</HTML>
