//{$Id$}

{$H+}{$MODE OBJFPC}
program pwserver;

{ simple HTTP test server for FPC webserver unit					}
{ based on pswebserver (c) by Vladimir Sibirov 						}
{ modified by Hartmut Eilers <hartmut@eilers.net> 					}

{ (c) 2006 by Hartmut Eilers < hartmut@eilers.net					}
{ distributed  under the terms of the GNU GPL V 2					}
{ see http://www.gnu.org/licenses/gpl.html for details					}



uses
{$ifdef LINUX}
	cthreads,
{$endif}
	crt, webserver;

const 	BLOCKED=true;
	nothreads=false;
	usethreads=true;
	debug=true;

var
	Seite,
	SeitenStart,
	SeitenEnde,
	Counter	: AnsiString;
	cnt	: word;


procedure embeddedWeb;
var
	laber	: string;
{ every time the special URL is called this procedure generates 	}
{ some dynamic content, delivered to the browser					}
begin
	SeitenStart:='<html><body>embedded special data:';
	SeitenEnde:=' <br><a href=/index.html>back</a></body></html>';
	laber:='<br>Data I last got via HTTP:'+GetParams+'<br>';
	Seite:=SeitenStart+Counter+laber+SeitenEnde;
	writeln('embeddedWeb:>Sending Page');
	{ der erste Parameter gibt an, wer die Seite sendet, Anwenderprogramme sollten immer 0 Ã¼bergeben }
	{ intern wird in der unit der parameter zur kennzeichnung der threads benutzt	}
	SendPage(0,Seite);
	writeln('embeddedWeb:>Page Send, finished');
end;

procedure embeddedWebReadParams;
var Url,Params :string;
begin
	Url:=GetURL;
	Params:=GetParams;
	writeln('embeddedWeb:> Got Parameters');
	writeln('URL=',Url,' Parameters=',Params);
end;

begin
	{ start the webserver with IP, Port, Document Root and Logfile and thread mode option, dbugging (on/off)}
	{ threadmode is currently not safe ! it random crashes }
	//start_server('10.63.9.9',10080,BLOCKED,'./docroot/','./pwserver.log',nothreads,true);
	start_server('0.0.0.0',10080,true,'./docroot','./pwserver.log',false,true);
	{ register special URL for content generated by this program }
	SetupSpecialURL('/status/index.html',@embeddedWeb );
	SetupVariableHandler(@embeddedWebReadParams);

	cnt:=0;
	Counter:='0';

	// Main loop doing the real stuff for the program
	repeat
		{ process the incomming requests }
		serve_request;
		write('.');
		delay(1); { this is was the real program does: waiting and counting :) }
		inc(cnt);
		str(cnt,Counter);
	until keypressed;
	stop_server; // stop the webserver
end.
